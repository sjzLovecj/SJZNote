{
  "posts": [
    {
      "content": "## 概述\n流媒体应用程序和长时间运行的发送连续更新的应用程序使用持续流来上载数据，而不是发送单个数据块或平面文件。您可以配置URLSessionUploadTask实例（URLSessionTask的子类）以使用您提供的流，然后将数据无限期填充。该任务通过调用会话的代理来获取流，因此您需要创建一个会话并将自己的代码设置为其代理。\n\n## 创建URL会话\n首先创建一个URLSession并为其提供代理，清单1使用默认的URLSessionConfiguration创建一个URL会话，并将self设置为代理。您稍后将在“上传任务提供流”中实现URLSessionTaskDelegate。\n\n清单1 使用代理创建URLSession\n```\nlazy var session: URLSession = URLSession(configuration: .default,\n                                          delegate: self,\n                                          delegateQueue: .main)\n```\n## 创建流上传任务\n使用URLSession方法uploadTask(withStreamedRequest:)创建上传任务。这需要一个URLRequest，它指定要上传的URL以及其他参数。通过调用resume启动任务。清单2显示了如何创建和启动上传任务，连接到监听端口12345的本地计算机（127.0.0.1) 上的服务器。\n清单2 创建上传任务\n```\nlet url = URL(string: \"http://127.0.0.1:12345\")!\nvar request = URLRequest(url: url,\n                         cachePolicy: .reloadIgnoringLocalCacheData,\n                         timeoutInterval: 10)\nrequest.httpMethod = \"POST\"\nlet uploadTask = session.uploadTask(withStreamedRequest: request)\nuploadTask.resume()\n```\n## 使用绑定的流对来提供输入流\n您将流数据作为inputStream提供给上传任务，任务从该流中读取数据并将其上传到目标。\n向输入流提供数据的一个好方法是使用一对绑定流。绑定对包含向其写入数据的OutputStream。由于流的绑定，您写入输出流的数据可用于输入流，然后任务可以从中读取数据，图1显示了这种安排。\n图1 使用一对编订的流向上传任务提供数据\n![](https://sjzlovecj.github.io//post-images/1606386222497.png)\n\n清单3 显示了一个名为Streams的结构，他由InputStream和OutputStreram组成。清单通过调用getBoundStreams(withBufferSize:inputStream:outputStream:)方法，为输入和输出流传入和传出引用，来穿件这种类型的属性，称为boundStreams。\n清单3 创建一对绑定的输入和输出流\n```\nstruct Streams {\n    let input: InputStream\n    let output: OutputStream\n}\nlazy var boundStreams: Streams = {\n    var inputOrNil: InputStream? = nil\n    var outputOrNil: OutputStream? = nil\n    Stream.getBoundStreams(withBufferSize: 4096,\n                           inputStream: &inputOrNil,\n                           outputStream: &outputOrNil)\n    guard let input = inputOrNil, let output = outputOrNil else {\n        fatalError(\"On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams.\")\n    }\n    // configure and open output stream\n    output.delegate = self\n    output.schedule(in: .current, forMode: .default)\n    output.open()\n    return Streams(input: input, output: output)\n}()\n```\n创建绑定流对时，请确保指定一个缓冲区大小，以便在从输入流读取数据之前保存写入输出流的任何数据。清单3使用4096字节的缓冲。\n\n该列表还将self设置为输出流的代理，声明您的类实现了StreamDelegate协议，以便接受指示输出流何时准备接受新数据的事件。稍后，您将准备就绪时将数据写入流中提供StreamDelegate的实现。\n\n> 提示\n> 您的StreamDelegate和URLSessionTaskDelegate的实现可以在同一类中，也可以在不同的类中，以对您的应用架构更有意义的方式为准。\n\n## 为上传任务提供流\n您可以在URLSessionTaskDelegate方法urlSession（_：task：needNewBodyStream :)的实现中为上载任务提供输入流，在您通过调用resume（）启动上载任务后会调用该输入流。 回调传递一个完成处理程序，您可以直接调用它，传递您先前创建的boundStreams.input流。 清单4显示了此方法的实现。\n清单4 在委托回调中向上传任务提供输入流\n```\nfunc urlSession(_ session: URLSession, task: URLSessionTask,\n                needNewBodyStream completionHandler: @escaping (InputStream?) -> Void) {\n    completionHandler(boundStreams.input)\n}\n```\n\n## 准备好后将数据写入流\n",
      "data": {
        "title": "上传数据流",
        "date": "2020-11-26 14:14:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "shang-chuan-shu-ju-liu"
    },
    {
      "content": "## 概览\n许多应用程序都与服务器一起使用，这些服务器接受图像或文档之类的文件上传，或者使用接收结构化数据的Web服务的API端点，例如JSON。要从您的应用上传数据，您可以使用URLSession实例来创建URLSessionUploadTask实例。上传任务使用URLRequest实例，该实例详细说明如何执行上传。\n\n## 准备上传数据\n要上传的数据可以是文件、流或数据的内容，如以下代码所示。\n许多Web服务端点都采用JSON格式的数据，您可以通过对数组和字典等可编码类型使用JSONEncoder类创建该对象。如以下代码所示，您可以声明一个符合Codable的结构，创建此类型的实例，然后使用JSONEncoder将实例编码为JSON的数据进行上传。\n代码 准备JSON数据上传\n```\nstruct Order: Codable {\n    let customerId: String\n    let items: [String]\n}\n\n// ...\n\nlet order = Order(customerId: \"12345\",\n                  items: [\"Cheese pizza\", \"Diet soda\"])\nguard let uploadData = try? JSONEncoder().encode(order) else {\n    return\n}\n```\n创建数据实例还有许多其他方法，例如将图像编码为JPEG或PNG数据，或使用UTF-8等编码将字符串转换为数据。\n## 配置上传请求\n上传任务需要URLRequest实例。如下代码所示，根据服务器的支持和期望，将请求的httpMethod属性设置为“POST”或“PUT”。使用setValue(_: forHTTPHeaderField:)方法设置要提供的任何HTTP请求头的值，Content-Length等除外。改会话会根据数据大小自动计算出内容长度。\n\n代码 配置URL请求\n```\nlet url = URL(string: \"https://example.com/post\")!\nvar request = URLRequest(url: url)\nrequest.httpMethod = \"POST\"\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n```\n## 创建并启动上传任务\n要开始上传，请在URLSession实例上调用uploadTask(with:from:completionHandler:)以创建一个上传URLSessionTask实例，并传入请求和您先前设置的数据实例。由于任务以挂起状态开始，因此您可以通过在任务上调用resume方法来开始网络加载过程。以下代码使用共享的URLSession实例，并在完成处理程序中接收其结果。处理程序在使用任何返回的数据之前检查传输和服务器错误。\n\n代码 启动上传任务\n```\nlet task = URLSession.shared.uploadTask(with: request, from: uploadData) { data, response, error in\n    if let error = error {\n        print (\"error: \\(error)\")\n        return\n    }\n    guard let response = response as? HTTPURLResponse,\n        (200...299).contains(response.statusCode) else {\n        print (\"server error\")\n        return\n    }\n    if let mimeType = response.mimeType,\n        mimeType == \"application/json\",\n        let data = data,\n        let dataString = String(data: data, encoding: .utf8) {\n        print (\"got data: \\(dataString)\")\n    }\n}\ntask.resume()\n```\n\n## 或者， 通过设置委托上传\n作为完成处理程序方法的替代方法，您可以在您配置的会话上设置委托，然后使用uploadTask（with：from :)创建上传任务。 在这种情况下，您将实现URLSessionDelegate和URLSessionTaskDelegate协议中的方法。 这些方法接收服务器响应以及任何数据或传输错误。\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "将数据上传到网站",
        "date": "2020-11-26 13:50:29",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jiang-shu-ju-shang-chuan-dao-wang-zhan"
    },
    {
      "content": "### 概述\n通过从URL会话创建数据任务，直接接收数据到内存中。\n\n对于与远程服务器的小型交互，可以使用URLSessionDataTask类将响应数据接收到内存中（与使用URLSessionDownloadTask类不同，后者将数据直接存储到文件系统中）。数据任务非常适合调用Web服务端点之类的用途。\n\n您使用URL会话实例创建任务。如果您的需求很简单，则可以使用URLSession类的共享实例。如果要通过委托回调与传输进行交互，则需要创建一个会话，而不是使用共享实例。您在创建会话时使用URLSessionConfiguration实例，同时传入实现URLSessionDelegate或其自协议之一。会话可以重复使用来创建多个任务，因此对于所需的每个唯一配置，创建一个会话并将其存储为属性。\n\n> 注意\n> 不要创建超出您需要的会话。例如，如果您的应用程序有几部分需要类似配置的会话，请创建一个会话并在他们之间共享。\n\n建立会话后，可以使用dataTask初始化方法之一创建数据任务。任务以挂起状态创建，可以通过调用resume方法启动\n\n### 使用完成处理程序接收结果\n获取数据的最简单方法是创建一个使用完成处理程序的数据任务。通过这种安排，任务将服务器的相应、数据以及可能的错误传递到您提供的完成处理程序块。下图显示了会话和任务之间的关系，以及如何将结果传递给完成处理程序。\n图 创建完成处理程序以接收任务结果\n![](https://sjzlovecj.github.io//post-images/1606360444093.png)\n要创建使用完成处理程序的数据任务，请调用URLSession的dataTask(with:)方法。您的完成处理程序需要做三件事：\n1. 验证错误参数为nil，如果不是，则说明发生了传输错误；处理错误并退出\n2. 检查响应参数以验证状态码指示成功，并且MIME类型是期望值。如果不是，请处理服务器错误并退出\n3. 根据需要使用数据实例\n\n下面代码 显示了用户获取URL内容的startLoad()方法。首先使用URLSession类的共享实例创建一个数据任务，将其结果传递给完成处理程序。检查本地和服务器错误后，此处理程序将数据转换为字符串，并使用其填充WKWebView。当然，您的应用程序可能还有其他用途来获取数据，例如将其解析为数据模型。\n```\nfunc startLoad() {\n    let url = URL(string: \"https://www.example.com/\")!\n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error = error {\n            self.handleClientError(error)\n            return\n        }\n        guard let httpResponse = response as? HTTPURLResponse,\n            (200...299).contains(httpResponse.statusCode) else {\n            self.handleServerError(response)\n            return\n        }\n        if let mimeType = httpResponse.mimeType, mimeType == \"text/html\",\n            let data = data,\n            let string = String(data: data, encoding: .utf8) {\n            DispatchQueue.main.async {\n                self.webView.loadHTMLString(string, baseURL: url)\n            }\n        }\n    }\n    task.resume()\n}\n```\n> 重要\n> 完成处理程序的创建和调用是在不同的Grand Central Dispatch队列上的。因此，任何使用数据或错误来更新UI工作都应明确放置在住队列中。\n\n### 与代理一起接收传输详细信息和结果\n为了再任务进行时对任务活动更大程度的访问，在创建数据任务时，您可以在会话上设置委托，而不是提供完成处理程序。下图显示了这种模式\n图 实现委托以接收任务结果\n![](https://sjzlovecj.github.io//post-images/1606368072926.png)\n\n通过这种方法，部分数据会在到达时提供给URLSessionDataDelegate的urlSession(_:dataTask: didReceive:)方法，直到传输完成或失败并出现错误。随着转移的进行，委托还接收其他类型的事件。\n\n使用委托时，您需要创建自己的URLSession实例，而不是使用URLSession类的简单共享实例。创建一个新的会话是您可以将自己的类设置为会话的委托，如下列代码所示。\n\n声明您的类实现一个或多个委托协议（URLSessionDelegate，URLSessionTaskDelegate，URLSessionDataDelegate和URLSessionDownloadDelegate）。然后使用初始化程序init(configuration: delegate:delegateQueue:)创建URL会话实例。您可以定制与此初始化程序一起使用的配置实例。例如，将waitsForConnectivity设置为true是个好主意，这样，会话将等待适当的连接，而不是在所需的连接不可用时立即失败。\n\n程序 创建使用委托的URLSesstion\n```\nprivate lazy var session: URLSession = {\n    let configuration = URLSessionConfiguration.default\n    configuration.waitsForConnectivity = true\n    return URLSession(configuration: configuration,\n                      delegate: self, delegateQueue: nil)\n}()\n```\n\n下面代码 显示了一个startLoad()方法，改方法使用此会话启动数据任务，并使用委托回调处理接收到的数据和错误。此代码实现了三个委托回调：\n- `urlSession(_:dataTask:didReceive:completionHandler:)`验证相应是否具有成功的HTTP状态码，并且MIME类型是text/html或text/plain。如果情况并非如此，则任务将被取消；否则，允许继续执行\n- `urlSession(_:dataTask:didReceive:) `接收任务接收到的每个Data实例，并将其添加到一个称为ReceivedData的缓冲区中\n- `urlSession(_:task:didCompleteWithError:) `首先查看是否发生了传输级错误。如果没有错误，它将尝试将接收到的数据缓冲区转换为字符串并将其设置为webView的内容。\n\n程序 使用带有URL会话数据任务的委托\n```\nvar receivedData: Data?\n\nfunc startLoad() {\n    loadButton.isEnabled = false\n    let url = URL(string: \"https://www.example.com/\")!\n    receivedData = Data()\n    let task = session.dataTask(with: url)\n    task.resume()\n}\n\n// delegate methods\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,\n                completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {\n    guard let response = response as? HTTPURLResponse,\n        (200...299).contains(response.statusCode),\n        let mimeType = response.mimeType,\n        mimeType == \"text/html\" else {\n        completionHandler(.cancel)\n        return\n    }\n    completionHandler(.allow)\n}\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {\n    self.receivedData?.append(data)\n}\n\nfunc urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n    DispatchQueue.main.async {\n        self.loadButton.isEnabled = true\n        if let error = error {\n            handleClientError(error)\n        } else if let receivedData = self.receivedData,\n            let string = String(data: receivedData, encoding: .utf8) {\n            self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)\n        }\n    }\n}\n```\n各种委托协议提供了以上代码中所示方法之外的方法，用于处理身份验证，重定向 和 其他特殊情况。在URLSession讨论中，使用URL会话描述了在传输过程中可能发生的各种回调。",
      "data": {
        "title": "将网站数据获取到内存中",
        "date": "2020-11-26 13:45:09",
        "tags": [
          "URL加载系统"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jiang-wang-zhan-shu-ju-huo-qu-dao-nei-cun-zhong"
    },
    {
      "content": "使用标准互联网协议与URL交互并与服务器通信。\n## 概览\nURL加载系统使用标准协议（如https或您创建的自定义协议）提供对URL标识资源的访问。加载是异步的，因此您的应用程序可以保持响应性，并在传入的数据或错误到达时对其进行处理。\n\n您使用URLSession实例穿件一个或多个URLSessionTask实例，这些实例可以获取数据并将其返回到您的应用程序，下载文件或将数据和文件上传到远程位置。要配置的话，请使用URLSessionConfiguration对象，改对象控制行为，例如如何使用缓存和cookie，或者是否允许在蜂窝网络上进行连接。\n\n您可以重复使用一个会话来创建任务。例如，网络浏览器可能有单独的会话供常规和私人浏览使用，其中私有会话不会缓存其数据。下图 显示了使用这些配置的两个会话如何创建多个任务。\n\n图 从URL会话创建任务\n![图1从URL会话创建任务](https://sjzlovecj.github.io//post-images/1606357598382.png)\n\n每个会话都与一个委托关联，以接收定期更新（或错误）。默认委托调用您提供的完成处理程序块；如果您选择提供自己定义的委托，则不调用此块。\n\n您可以将会话配置为后台运行，这样当应用程序暂停时，系统可以代表它下载数据并唤醒应用程序以交付结果。\n\n\n\n\n",
      "data": {
        "title": "URL加载系统",
        "date": "2020-11-26 10:07:40",
        "tags": [
          "URL加载系统"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "url-jia-zai-xi-tong"
    },
    {
      "content": "## 3.1 深入iOS网络开发技术\n应用程序中网络访问都需要通过URL来进行，iOS中的URL加载系统包含许多类与协议，这些类和协议互相协作完成URL加载的信息配置、协议支持、身份验证、Cookie和缓存功能。![URL加载相关类的关系表](https://sjzlovecj.github.io//post-images/1606269189646.png)\n\n1. NSURLRequest类负责一个具体的网络请求，其内部封装一个请求路径NSURL对象，如果需要对请求参数进行配置，则可以使用NSMutableURLRequest\n2. NSURLResponse类封装了请求的响应数据，响应数据包括两部分，一部分是返回数据的状态码，数据长度、编码等信息。另一部分是内容数据本身\n3. NSURLCredential、NSURLProtectionSpace、NSURLCredentialStorage、NSURLAuthenticatioChallenge这4个类对请求凭证进行相关设置\n4. NSURLCache类用于管理NSURLRequest请求缓存\n5. NSHTTPCookieStorage、NSHTTPCookie是用于持久化存储HTTP请求的Cookie数据\n\n### 3.1.1 初识NSURLSession\nSession表示会话，一个网络连接的建立可以理解为会话的建立。NSURLSession提供了如下三种类型的网络会话：\n- Default类型：提供前台请求相关方法，支持配置缓存、身份凭证等\n- Ephemeral类型：即时请求类型，不使用缓存、身份凭证等\n- Background：后台类型，支持在后台完成请求任务\n\n在每个网络会话中可以添加多个网络请求任务，网络请求任务也有如下三种类型：\n- 数据任务：使用NSData对象进行数据的发送和获取，一般用于短数据的任务。\n- 下载任务：下载文件数据，支持后台下载\n- 上传任务：以文件的形式上传数据，支持后台上传\n\n通过NSURLSessionConfiguration类对象可以对NSURLSession进行配置与创建\n在使用NSURLSession进行网络请求时需要创建NSURLSessionTask对象，每一个NSURLSessionTask对象就是一个请求任务，有两种方式来获取请求返回的数据，一种通过Block，一种通过代理回调\n\n如果进入后台，代理方法将不再被回调，下载完成将调用AppDelegate中的如下方法`application:handleEventsForBackgroundURLSession:completionHandler:`\n",
      "data": {
        "title": "第三章 应用程序网络与能耗优化",
        "date": "2020-11-25 09:27:35",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "di-san-zhang-ying-yong-cheng-xu-wang-luo-yu-neng-hao-you-hua"
    },
    {
      "content": "## 2.1 iOS的内存管理模型\n### 2.1.1 关于内存消耗与引用计数\n当引用程序启动后，除了代码和系统数据会消耗一部分内存外，开发者在程序中创建的任何对象都会消耗内存。iOS程序中，内存通常被分成如下5个区域：\n- 栈区：存储局部变量，在作用域结束后内存会被回收\n- 堆区：存储OC对象，需要开发者手动申请和释放\n- BSS区：用来存储未初始化的全局变量和静态变量\n- 数据区：用来存储已经初始化的全局变量、静态变量 和 常量\n- 代码段：加载代码\n\n除了堆区需要开发者手动进行内存管理外，其他区都由系统自动进行回收\n\n引用计数是OC语言提供的内存管理技术，每一个OC对象都有一个retainCount属性。\n\n### 2.1.2 MRC内存管理\n关闭ARC：\n将TARGETS -> Build Settings -> Objective-C Automatic Reference Counting设置为NO\n\nMRC内存管理有如下两个原则：\n- 谁持有，谁负责释放，不是自己持有的不能释放\n- 当对象不再被需要时，需要主动释放\n\n| 函数名 | 意义 |\n| --- | --- |\n| alloc | 进行内存分配 |\n| new | 创建并初始化对象 |\n| copy | 复制对象 |\n| mutablecoy | 可变复制对象 |\n| retain | 进行持有 |\n\nalloc、new、copy新创建一个对象，该对象引用计数为1，当需要时，调用release使引用计数减1\nretain使对象的引用计数加1，当不再使用对象时，需要调用release，使引用计数减1\n\n### 2.1.3 关于ARC\n所有权修饰符：\n- __strong：修饰符通常用来对变量进行强引用\n    1. 使用__strong修饰的变量如果是自己生成的，则会被添加到自动释放池中，并在作用域结束时，release一次\n    2. 使用__strong修饰的变量如果不是自己生成的，则会被强引用，即会被持有使其引用计数增加1，在离开作用域后会被release一次\n    3. 使用__strong修饰的变量如果重新复制或者置为nil，则会被release一次\n  \n- __weak：修饰符通常用来对变量进行弱引用，最大的用途是避免ARC环境下循环引用问题\n    1. 被__weak修饰的变量仅提供弱引用，不会使引用计数增加。如果变量是自己生成，则会被添加到自动释放池，会在离开作用域时被release一次；如果不是自己生成，则在离开作用域之后，不会进行release操作\n    2. 被__weak修饰的变量指针，变量如果失效，则指针会被自动置为nil，这是一种比较安全的设计方式，大量减少野指针造成的异常。\n\n- __unsafe_unretained：这个修饰符是不安全的，这个修饰符也是对变量进行弱引用，不同的是，当变量对象失效时，其指针不会被自动置为nil，会产生野指针\n    1. 被__unsafe_unretained修饰的变量仅提供弱引用，不会使其引用计数增加。变量如果是自己生成的，则会在离开作用域的时候被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作\n    \n- __autoreleasing：这个修饰符与自动释放池有关\n    \nARC还需要牢记如下几条原则：\n1. 不能使用retain、release、autorelease函数，不可访问retainCount属性\n2. 不能调用dealloc函数，可以覆写dealloc函数，但在实现中不可调用父类的dealloc函数\n3. 不能使用NSAutoreleasePool，可以使用@autoreleasepool替代\n4. 对象型变量不能作为C语言的结构体\n\n### 2.1.4 属性修饰符\n在探讨类的定义时：类是属性与方法的集合\n- 属性用来存储类中的数据\n- 方法用来描述类中的行为\n\n\n| 名称 | 作用 |\n| --- | --- |\n| assign | 直接赋值，与引用计数无关，用来声明简单数据类型的属性，如Int |\n| retain | 对旧对象进行释放，并强引用新的对象，使其引用计数加1，用在MRC中 |\n| strong | 对新对象进行强引用，使用旧对象，使其引用计数加1，作用与retain类似，用在ARC中 |\n| copy | 在实现Setter方法时，采用copy函数，会生成新的对象被自己持有 |\n| weak | 弱引用，不对所赋值的对象进行持有，但是是安全的，当对象不可用时，会被置为nil，用在ARC |\n| unsafe_unretained | 弱引用，和weak不同的是，如果引用的对象不可用，则当指针不会被置为nil，会产生野指针 |\n\n### 2.1.5 ARC 和 MRC进行混编\n1. 将TARGETS -> Build Settings -> Objective-C Automatic Reference Counting设置为YES\n2. 在工程的Build Phases选项中的Compile Sources中对应的文件添加-fno-objc-arc，（在MRC中添加ARC文件，则-fobjc-arc）\n\n## 2.2 自动释放池\n### 2.2.1 关于autorelease方法\n1. 当引用计数为0时，内存进行释放\n2. release会使对象的引用计数减1\n3. autorelease，为自动释放，本质上是使release函数的调用被延迟了\n4. 自动释放对象的内存管理是交给自动释放池处理的\n\n### 系统维护的自动释放池\niOS系统在运行的时候，会自动创建一些线程，每一个线程都默认拥有自动释放池，在每次时间循环时，都会将其自动释放池清空\n\n## 2.3 杜绝内存泄漏\n1. 循环引用\n2. Block循环引用，使用__weak解决\n3. 代理与循环引用，使用weak修饰符解决\n4. 定时器引起的内存泄漏，定时器对象会持有当前视图控制器，只有当定时器失效后，其才会释放所持有的当前视图控制器。调用invalidate方法\n\n## 2.4 关于僵尸对象\n### 2.4.1 捕获僵尸对象\n在Objective-C中，内存的使用包含下面几个阶段：\n- 请求创建对象，向系统申请一块内存空间，在申请完成后，这块内存空间不能再做他用 \n- 对象被释放，此时这块内存空间变为闲置，可以被申请使用\n- 在此块内存重新被申请使用前，这块内存中的数据依然存在\n- 此时如果依然有指针指向这块内存，则此指针为野指针\n- 当野指针对这块内存进行访问时，如果这块内存已经被重新分配，则会出现系统问题，如果没有被分配，则不会出现系统问题。\n\nXcode提供的可以捕获僵尸对象的工具：\nProduct->Edit SCheme->Run->勾选Zombie Objects\n\n在ARC中，使用__weak修饰和__strong修饰的变量指针变量释放后会被自动置为nil，这就大大减少了野指针的问题，向nil指针发送任何消息都是无效的。\n\n\n## 2.5 CoreFoundation框架中的内存管理\nCoreFoundation也提供了字符串、数组、集合、颜色、时间和URL等对象。\n\n### 2.5.1 CoreFoundation中的引用计数\n在CoreFoundation框架中，有几条内存管理法则：\n1. 自己创建的对象要自己负责释放\n2. 如果使用别人创建的对象，要保证其可用，则需要对对象进行持有\n3. 如果对对象进行了持有，则当不再需要此对象时，要进行释放\n\n- 在CoreFoundation框架中，使用带有Create、Copy这样的字段的函数获取的对象会被认为是我们自己创建的对象，我们自己要负责这些对象的释放\n- 当使用带有Get这样的字段的函数获取对象时，默认并不对此对象进行持有，可以手动调用CGRetain()函数进行持有\n\n### 2.5.2 CoreFoundation框架与Foundation框架混用\n可以通过桥接的方式在CoreFoundation和Foundation框架间灵活地转换对象\n\n- 使用__bridge关键字可以进行CoreFoundation对象和Foundation对象的互相转化，使用__bridge进行转换的对象的对象的引用计数并不会做任何额外操作\n\n```\nCFUUIDRef uuid = CFUUIDRef(NULL);\n__weak NSUUID * uid = (__bridge NSUUID *)(uuid);\nCFRelease(uuid);\n```\n\n- 还有一种专门用来将Foundation对象转换成CoreFoundation对象的桥接关键字__bridge_retained，不同于__bridge关键字转换后不会主动对对象引用计数操作，__bridge_retained关键字转换后会对对象进行强引用\n\n```\nNSUUID * uuid = [[NSUUID alloc] init];\nCFUUIDRef uid = (__bridge_retained CFUUIDRef)uuid;\n```\n与__bridge_retained对应，__bridge_transfer专门用来将CoreFoundation对象转换为Foundation对象。\n\n```\nCFUUIDRef uuid = CFUUIDCreate(NULL);\nNSUUID * uid = (__bridge NSUUID *)(uuid);\nCFRelease(uuid);\n```\nARC环境下默认生了了uid的修饰符__strong，因此实际上uid对uuid对象进行了一次强引用，所以当向uuid发送release消息后，内存并没有被释放，依然可以被正常访问。\n\n```\nCFUUIDRef uuid = CGUUIDCreate(NULL);\nNSUUID * uid = (__bridge_transfer NSUUID*)(uuid);\nCGRelease(uuid);\n```\n运行工程，会发现程序会直接发生Crash，__bridge_transfer的作用是在转换后主动进行一次释放操作，可以简单解释，__bridge_transfer将原对象的所有权交给了转换后的指针，虽然上面uid默认使用__strong修饰，会使引用计数加1，但是其主动的release又会使引用计数减1，后面我们又进行了release操作，因此对象被释放，之后的访问产生Crash。\n\n## 2.6 扩展：关于id 与 void*\n### 2.6.1 关于id类型\nid是Objective-C中定义的一种泛型实现，它可以表示任何对象类型。\n- 作为参数或返回值\n- id类型的参数不会进行类型检查\n    - 声明为id类型的对象就相当于告诉了编译器不进行类型检查，使用id类型的对象可以调用任何方法，都不会进行类型检查\n- id<protocol>是一种优雅的编程方式\n    - id类型不会进行编译检查，因此约束类型方法实现的最好方式就是通过协议。\n\n### 2.6.2 关于void与void*\nObjective-C语言的函数必须有一个确定的返回值类型，如果没有返回值，则需要使用void来标记返回值类型\n\nvoid* 描述的实际上是任意类型的指针，这里和id很像，虽然id描述的是Objective-C对象，但是本质上也是指针，根据推测，id类型的数据和void* 类型的数据是可以进行类型转换的\n\n事实上，MRC环境下确实如此，ARC下需对OC对象进行引用计数管理，对C语言指针并不会，ARC下不允许直接将id与void* 进行转换，需要用桥接的方式\n\n类型检查都是编译时的特性，真正传递的数据依然在运行时决定",
      "data": {
        "title": "第二章 iOS的内存管理模型",
        "date": "2020-11-24 18:37:38",
        "tags": [
          "iOS性能优化"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "di-er-zhang-ios-de-nei-cun-guan-li-mo-xing"
    },
    {
      "content": "所谓性能，无非是一种指标，在软件开发中，该指标往往会关注两方面：效率和消耗\n- 效率主要是指代码的执行效率、动画的流畅度、应用的冷启动时间和热启动时间、网络通信的阻塞时间等\n- 消耗主要是指内存的消耗、有没有内存泄露、CPU的占有率、耗电与应用程序包尺寸\n\n### 1.1 衡量应用程序性能优劣的一些标准\n#### 1.1.1 代码的执行效率\n当项目足够复杂、数据处理量足够大时，代码执行效率往往是最难优化的。\n执行效率受如下几个方面的影响：\n- 算法依据的数据基础\n- 编译器产生的代码质量和语言的执行效率\n- 问题的输入规模\n- 硬件的执行速度\n\n递归函数极容易产生时间复杂度为O(n!)的代码，多层嵌套的循环结构也会大大增加算法的时间复杂度。在编写程序时，要尽量将循环层数控制在3层以内，在使用递归函数时要格外小心。\n\n#### 1.1.2 内存占用",
      "data": {
        "title": "第一章 关于性能需要知道的事",
        "date": "2020-11-24 18:36:52",
        "tags": [
          "iOS性能优化"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "di-yi-zhang-guan-yu-xing-neng-xu-yao-zhi-dao-de-shi"
    },
    {
      "content": "1. UITableView 或 UICollectionView，点击没反应 或者 视图被遮挡\n> 原因: UITableView 或 UICollectionView的Cell视图层级改变，视图加载完成之后，contentView在Cell子视图的最上层，自己添加到Cell上的子控件被contentView遮挡\n\n> 更改：不要将控价直接添加到Cell上，要添加到Cell的contentView上面\n\n2. Xcode12打包上线后，iOS12上滑动UITableView 或 UICollectionView崩溃（自己运行找不到）\n> 原因：Xcode12打包上线后，iOS12上大面积崩溃，代码中 返回UITableViewCell 和 UICollectionViewCell的时候，判断最后返回了nil，\n> 还有一部分是向已经释放的对象（野指针）发送消息，主要原因 程序存在 内存泄漏(这个应该不算适配问题，自己写代码不注意的问题)\n\n> 依据：崩溃日志中：[Exception Type: EXC_BAD_ACCESS (SIGSEGV)](https://blog.csdn.net/dreamersharon/article/details/49561481)\n\n\n> 修改：通过Analyze静态分析，将所有可能造成泄漏的地方修改掉\n\n3. Xcode12 打包后，信号量崩溃\n> 原因：信号量使用不当，可能因为线程优先级，造成了内存问题\n> 修改：没有特别好的办法，去掉了信号量的使用\n\n4. Xcode12 编译第三方库失败\n> 报错：building for iOS Simulator, but linking in object file built for iOS\n> 原因：原来xcode12模拟器已经用arm架构来编译项目了，而link链接的还是x86架构\n> 修改：Target--Build Settings--VALID_ARCHS 中添加需要的架构\n            或将VALID_ARCHS删除掉（目前采取 去掉的方式）\n\n5.  私有库中使用.a 或者 .framework，cocoaPods lint失败\n  > 报错：Ld /Users/sjz/Library/Developer/Xcode/DerivedData/App-emljzuayowfblgduqgmiktqhgmzy/Build/Intermediates.noindex/App.build/Release-iphonesimulator/App.build/Objects-normal/i386/Binary/App normal i386\n> 相似问题：i386 换成 arm64 或者 armv7\n   \n> 修改：在podspace文件中添加：s.pod_target_xcconfig = { 'VALID_ARCHS' => 'x86_64 armv7 arm64'}\n> 还需要将：\n> Excluded Architecture 加上 arm64  （这个我承认，我没添加）\n> Build Active Architecture Only 设置为 NO\n\n6. 私有库中使用.a 或者 .framework，其他工程引入该私有库，正常运行，打包报错：\n```\nld: bitcode bundle could not be generated because '/Users/sjz/Desktop/workPlace/你的工程/Pods/私有库/Pods/BaiduMapKit/BaiduMapKit/BaiduMapAPI_Base.framework/BaiduMapAPI_Base(FontRenderer.o)' was built without full bitcode. All object files and libraries for bitcode must be generated from Xcode Archive or Install build file '/Users/sjz/Desktop/workPlace/你的工程/Pods/私有库/Pods/BaiduMapKit/BaiduMapKit/BaiduMapAPI_Base.framework/BaiduMapAPI_Base' for architecture armv7\n```\n> 分析\n> 1. bitcode bundle could not be generated was built without full bitcode.说明BaiduMapAPI_Base不支持开启bitcode\n> 2. 工程 和 私有库中 bitcode 已经全设置成 NO\n> 3. 打包还不成功\n> 4. 说明 私有库 中bitcode的开启受 有某些 依赖库 的影响\n\n解决方案：在工程的 podfile中添加（在私有库中添加，并没有起到作用）\n```\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['ENABLE_BITCODE'] = 'NO'\n    end\n  end\nend\n```\n\n\n\n   ",
      "data": {
        "title": "Xcode12 iOS14 适配",
        "date": "2020-10-26 10:40:29",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "xcode12-ios14-gua-pei"
    },
    {
      "content": "Product->Analyze ，静态分析警告\nUser-facing text should use localized string macro\n\n将 Build Settings -> Missing Localizability -> 设置为NO",
      "data": {
        "title": "iOS之\"User-facing text should use localized string macro”警告的解决",
        "date": "2020-10-21 13:55:41",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ios-zhi-user-facing-text-should-use-localized-string-macrojing-gao-de-jie-jue"
    },
    {
      "content": "能正常真机测试，但build的时候会失败（红色警告）\n升级xcode12后，项目在run debug时候是正常运行的，但是在build或者run release的时候就会出现如标题的红色错误。\n\n在网上找到解决方法：\n\n在Target-Build Settings-Excluded Architectures中添加以下代码EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_simulator__NATIVE_ARCH_64_BIT_x86_64=arm64 arm64e armv7 armv7s armv6 armv8 EXCLUDED_ARCHS=$(inherited) $(EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_$(EFFECTIVE_PLATFORM_SUFFIX)__NATIVE_ARCH_64_BIT_$(NATIVE_ARCH_64_BIT))\n\n参考答案：https://cloud.tencent.com/developer/article/1704754\n\n相关回答： https://stackoverflow.com/questions/63607158/xcode-12-building-for-ios-simulator-but-linking-in-object-file-built-for-ios",
      "data": {
        "title": "linked library ‘libPods-xxx.a‘ is missing one or more architectures required by this target: armv7.",
        "date": "2020-10-16 16:31:30",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "linked-library-libpods-xxxa-is-missing-one-or-more-architectures-required-by-this-target-armv7"
    },
    {
      "content": "\n![](https://sjzlovecj.github.io//post-images/1602750924481.png)",
      "data": {
        "title": "iOS12:WKWebView修改user-agent遇到的重大bug",
        "date": "2020-10-15 16:34:46",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ios12wkwebview-xiu-gai-user-agent-yu-dao-de-chong-da-bug"
    },
    {
      "content": "[NSPlaceholderMutableString initWithString:]: nil argument\n- 拼接字符串中有空字符串\n\n-[NSURLError objectForKey:]: unrecognized selector sent to instance 0x28153ad90\n- 这些需要类型判断，有些类型不能使用objectFotKey取值\n\n-[_NSInlineData objectForKeyedSubscript:]: unrecognized selector sent to instance 0x1c047be40 (null)\n- \n\n\n\n",
      "data": {
        "title": "iOS线上崩溃",
        "date": "2020-10-15 14:13:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ios-xian-shang-beng-kui"
    },
    {
      "content": "在 podspec文件中添加：\n```\nvalid_archs = ['armv7s','arm64',]\ns.xcconfig = {\n  'VALID_ARCHS' =>  valid_archs.join(' '),\n}\ns.pod_target_xcconfig = {\n    'ARCHS[sdk=iphonesimulator*]' => '$(ARCHS_STANDARD_64_BIT)'\n}\n```\n指定支持的框架",
      "data": {
        "title": "cocoaPods symbol(s) not found for architecture i386",
        "date": "2020-09-27 14:30:10",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cocoapods-symbols-not-found-for-architecture-i386"
    },
    {
      "content": "这是今天遇到的一个BUG,是在Debug下,\nbecause its architectures 'arm64' didn't contain all required architectures 'armv7 arm64'\n\n原因是cocoapods下依赖\n\n只要把Build Settings下的  Build Active Architecture Only  设置为YES就可以了\n\n## 可以解决  依赖第三方库 找不到头文件的问题\n\nBuild Active Architecture Only：是否只编译当前设备适用的指令集（如果这个参数设为YES，使用iPhone 6调试，那么最终生成的一个支持ARM64指令集的Binary。一般在DEBUG模式下设为YES，RELEASE设为NO）\n\n将Debug设置为YES,Release设置为NO。若两个都设置为YES上架打包用iPhone5s以上的手机编译发布包时不会支持iPhone5s以下的设备；用iPhone5以下的手机打包时的ipa包不包含64位。",
      "data": {
        "title": "because its architectures 'arm64' didn't contain all required architectures 'armv7 arm64'",
        "date": "2020-09-22 13:51:52",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "because-its-architectures-arm64-didnt-contain-all-required-architectures-armv7-arm64"
    },
    {
      "content": "- 什么是越狱\n    - 利用iOS漏洞，获取iOS系统的最高权限（Root），解开之前的各种限制（合法行为）\n\n- 越狱的好处\n    - 打造个性化、与众不同的iPhone\n        - 自由安装各种实用的插件、主题、APP\n        - 修改系统APP的一些默认行为\n\n    - 自由安装非AppSore来源的APP\n        - “付费APP”秒变“免费APP”\n        - 未越狱的iPhone安装APP的渠道\n            - appStore\n            - 真机调试\n            - 通过证书打包签名ipa安装\n        - 灵活管理文件系统，让iPhone可以像U盘那样灵活\n    - 给开发者提供了逆向工程的环境\n\n- 缺点\n    - 不保修\n    - 费电，越狱后的iOS系统会常驻一些进程，耗电速度约提升10%~20%\n    - 在新的iOS固件版本出来的时候，不能及时地进行更新\n        - 每个新版本的固件，都会修复上一个版本的越狱漏洞，使越狱失效\n        - 如果需要保持越狱状态，要等待新的预约程序发布时，才能升级相应的固件版本\n    - 不再受iOS系统默认的安全保护，容易被恶意软件攻击，个人隐私有被窃取的风险\n    - 如果安装了不稳定的插件，容易让系统变的不稳定、变慢，甚至出现白苹果等问题\n  \n### 完美预约和不完美越狱\n- 完美越狱\n    - 越狱后的iPhone可以正常关机 和 重启\n- 不完美预约\n    - iPhone一旦关机后再开机时，屏幕会一直停留在启动页面，也就是 白苹果 状态\n    - 或者能正常开机，但已经安装的破解软件都无法正常使用，需要将设备与pc连接后，使用软件进行引导才能使用\n- 一般来说，在苹果发布新的iOS固件后，针对改固件的不完美越狱会先发布，随后完美越狱才可能发布\n    - 一般较新的系统版本，均为不完美越狱\n- 越狱方法推荐\n    - PP助手\n\n- 如果判断手机越狱成功\n    - 桌面是否有Cydia\n    - 工具判断（PP助手）\n\n- Cydia安装软件的步骤\n    - 添加软件源（不同软件的软件源可能不同）\n    - 进入软件源找到对应的软件，开始安装\n- SpringBoard 就是iOS的桌面\n\n\n- 必备软件安装\n    - Apple File Conduit 2\n        - 可以访问整个iOS设备的文件系统\n        - 软件源：http",
      "data": {
        "title": "iOS 越狱",
        "date": "2020-08-31 14:16:00",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ios-yue-yu"
    },
    {
      "content": "安装包（IPA）主要由可执行文件、资源组成\n\n- 资源（图片、音频、视频等）\n    - 采用无损压缩\n    - 去除没有用到的资源（LSUnusedResources）\n\n- 可执行文件瘦身\n    - 编译器优化\n        - Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为YES\n        - 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO，Other C Flags添加-fno-exceptions\n        - 利用AppCode 检测未使用的代码：菜单栏->Code->Inspect Code\n        - 编写LLVM插件检测出重复代码、未被调用的代码\n\n- LinkMap\n    - 生成LinkMap文件，可以查看可执行文件的具体组成",
      "data": {
        "title": "iOS安装包瘦身",
        "date": "2020-08-27 10:00:41",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ios-an-zhuang-bao-shou-shen"
    },
    {
      "content": "### App的启动过程\n1. APP的启动分为两种\n    - 冷启动：从零开始启动APP\n    - 热启动：APP已经在内存中，在后台存活着，再次点击图标启动APP\n  <!-- more -->\n\n2. App的启动过程\n    - 解析info.plist\n        - 加载相关信息，例如闪屏\n        - 沙盒建立，权限检查\n    - Mach-O加载\n        - 如果是胖二进制文件，寻找合适当前CPU类别的部分\n        - 加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法），进行rebase指针调整和bind符号绑定（dyld完成，运行时开始）\n        - 定位内部、外部指针引用，例如字符串、函数等\n        - 执行声明为`__attribute__((constructor))`的C函数\n        - 加载类扩展（Category）中的方法\n        - C++静态对象加载、调用ObjC的`+load`方法\n        - 进行各种objc结构的初始化（注册Objc类、初始化对象等等）\n        - 调用C++静态初始化器和__attribute__((constructor))装饰的函数\n    - 程序执行\n        - 调用`main()`\n        - 调用`UIApplicationMain()`\n        - 调用`application:didFinishLaunchingWithOptions:`\n\n3. 如何测量启动过程耗时\n    1.  main()函数之前\n        - 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -> Run -> Arguments）\n            - DYLD_PRINT_STATISTICS设置为1\n            - 如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1\n        ```\n        Total pre-main time: 3.0 seconds (100.0%)\n                dylib loading time: 1.4 seconds (47.3%)\n                rebase/binding time: 297.30 milliseconds (9.7%)\n                    ObjC setup time: 245.42 milliseconds (8.0%)\n                initializer time: 1.0 seconds (34.9%)\n                slowest intializers :\n                    libSystem.B.dylib :  11.39 milliseconds (0.3%)\n                libglInterpose.dylib : 489.71 milliseconds (15.9%)\n                        AFNetworking : 318.57 milliseconds (10.3%)\n                        SJZCoreModule : 317.69 milliseconds (10.3%)\n                        LYEmptyView : 131.32 milliseconds (4.2%)\n        ```\n        如何解读\n        1). main()函数之前总共使用了3s\n        2). 在3s中，加载动态库用了1.4s，指针重定位使用了297.30ms，ObjC类初始化使用了245.42ms，各种初始化使用了1s。\n        3). 在初始化耗费的1s中，用时最多的五个初始化是libSystem.B.dylib、libglInterpose.dylib、AFNetworking、SJZCoreModule、LYEmptyView\n\n    2. main()函数之后\n        - 指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。\n\n4. 影响启动性能的因素\n    每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持6个非系统动态库合并为一个\n    +load()方法里的内容可以放到首屏渲染完成后再执行，或使用+initialize()方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。\n\n    - mian()函数之前耗时的影响因素\n        - 动态库加载越多，启动越慢\n        - ObjC类越多，启动越慢\n        - C的constructor函数越多，启动越慢\n        - ObjC的+load越多，启动越慢\n\n\n    > 优化\n    > 1. 减少动态库、合并一些动态库（定期清理不必要的动态库）\n    > 2. 减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）\n    > 3. 合并功能类似的类和扩展（Category）\n    > 4. 减少C++虚函数数量\n    > 5. Swift尽量使用struct\n    > 6. 用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load方法\n    > 7. 压缩资源图片\n\n\n    - main() 函数之后耗时的影响因素\n        - 执行mian() 函数耗时\n        - 执行application:didFinishLaunchingWithOptions:耗时\n        - rootViewController及其childViewController的加载、view及其subviews的加载\n\n    ```\n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n        SJZTabBarController * tabBar = [[SJZTabBarController alloc] init];\n\n        ViewController * vc1 = [[ViewController alloc] init];\n        UINavigationController * nav1 = [[UINavigationController alloc] initWithRootViewController:vc1];\n        nav1.tabBarItem = [[UITabBarItem alloc] initWithTitle:@\"首页\" image:nil selectedImage:nil];\n        [tabBar addChildViewController:nav1];\n        \n        ViewController * vc2 = [[ViewController alloc] init];\n        UINavigationController * nav2 = [[UINavigationController alloc] initWithRootViewController:vc2];\n        nav2.tabBarItem = [[UITabBarItem alloc] initWithTitle:@\"首页\" image:nil selectedImage:nil];\n        [tabBar addChildViewController:nav2];\n        \n        \n        UIWindow * window = [[UIWindow alloc] initWithFrame:UIScreen.mainScreen.bounds];\n        window.rootViewController = tabBar;\n        [window makeKeyAndVisible];\n        self.window = window;\n        \n        return YES;\n     }\n    ```\n    那么`[SJZTabBarController viewDidLoad]`  `[ViewController viewDidLoad]`  `[AppDelegate application: didFinishLaunchingWithOptions:]` 调用顺序是怎么样的？\n    > 执行顺序为：\n    > 1. didFinishLaunchingWithOptions 开始执行 \n    > 2. 开始加载 SJZTabBarController 的 viewDidLoad\n    >  3. didFinishLaunchingWithOptions 跑完了\n    >  4. 开始加载 ViewController 的 viewDidLoad, 然后执行一堆初始化的操作\n\n    但如果在didFinishLaunchingWithOptions执行期间，操作了ViewController的view 以及 subView（初始化好的）的话\n    > 执行顺序将变为:\n    > 1. didFinishLaunchingWithOptions 开始执行 \n    > 2. 开始加载 SJZTabBarController 的 viewDidLoad\n    > 3. 开始加载 ViewController 的 viewDidLoad, 然后执行一堆初始化的操作\n    > 4. didFinishLaunchingWithOptions 跑完了\n\n    如果将界面的初始化、网络请求、数据解析、视图渲染等操作都放到了viewDidLoad，每次启动APP的时候，在用户看到第一个页面之前，APP将执行完以上所有的操作，才会进入视图渲染阶段。\n\n    所以，main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。\n    - 必要的配置信息，如埋点、日志等放到 didFinishLaunchingWithOptions中\n    - 初始化首页相关的代码，放到首页的viewDidLoad\n    - 其他与首页无关的SDK配置，网络请求，监听注册、配置文件读取等，放到首页viewDidAppear中\n\n    > 优化\n    > 1. 必须第一时间启动，仍然把它留在 didFinishLaunchingWithOptions 里启动。\n    > 2. 某些在用户进入APP主体之前必须要加载的功能，放到首页viewDidLoad 或 广告页的viewDidLoad\n    > 3. 非必须的，我们放到第一个界面的viewDidAppear\n\n### 优化的目标\n> 苹果给出的标准：\n> 应该在400ms内完成main()函数之前的加载\n> 整体过程耗时不能超过20秒，否则系统会kill掉进程，App启动失败\n\n这里要根据自己App的需求和规模，我们的目标应该有所取舍\n\n### 总结\n- 重新梳理架构，减少动态库（合并动态库）、ObjC类的数目，减少Category的数目\n- 定期扫描不再使用的动态库、类、函数\n- 用dispatchonce()代替所有的__attribute__((constructor))函数、C++静态对象初始化、ObjC的+load\n- 控制 C++ 全局变量的数量。\n- \n\n### 参考(其实大部分照抄😎)\n[iOS App 启动性能优化](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653579242&idx=1&sn=8f2313711f96a62e7a80d63851653639&chksm=84b3b5edb3c43cfb08e30f2affb1895e8bac8c5c433a50e74e18cda794dcc5bd53287ba69025&mpshare=1&scene=1&srcid=081075Vt9sYPaGgAWwb7xd1x&key=4b95006583a3cb388791057645bf19a825b73affa9d3c1303dbc0040c75548ef548be21acce6a577731a08112119a29dfa75505399bba67497ad729187c6a98469674924c7b447788c7370f6c2003fb4&ascene=0&uin=NDA2NTgwNjc1&devicetype=iMac16%2C2+OSX+OSX+10.12.6+build(16G29)&version=12020110&nettype=WIFI&fontScale=100&pass_ticket=IDZVtt6EyfPD9ZLcACRVJZYH8WaaMPtT%2BF3nfv7yZUQBCMKM4H1rDCbevGd7bXoG)\n[优化 App 的启动时间实践 iOS](https://www.jianshu.com/p/0858878e331f)\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "APP的启动时间优化",
        "date": "2020-08-25 14:07:33",
        "tags": [
          "APP的启动"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### App的启动过程\n1. APP的启动分为两种\n    - 冷启动：从零开始启动APP\n    - 热启动：APP已经在内存中，在后台存活着，再次点击图标启动APP",
      "fileName": "app-de-qi-dong-shi-jian"
    },
    {
      "content": "- API：应用程序编程接口\n    - 源代码和库之间的接口\n\n- ABI：引用程序二进制接口\n    - 应用程序与操作系统之间的底层接口\n    - 涉及的内容有：目标文件格式、数据类型的大小、布局、对齐、函数调用约定等等\n\n",
      "data": {
        "title": "Swift基础",
        "date": "2020-08-24 14:28:15",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "swift-ji-chu"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": null,
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](http://hvenotes.fehey.com/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "URL加载系统",
      "slug": "nLfk6Wbq8",
      "used": true
    },
    {
      "index": -1,
      "name": "iOS性能优化",
      "slug": "APKFCvrLv",
      "used": true
    },
    {
      "index": -1,
      "name": "APP的启动",
      "slug": "Ma4T4cJoZ",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "gridea",
      "used": true
    },
    {
      "index": -1,
      "name": "iOS直播",
      "slug": "sI-aRh1FM",
      "used": false
    },
    {
      "index": -1,
      "name": "Fluter",
      "slug": "cQf-AIo_0",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}
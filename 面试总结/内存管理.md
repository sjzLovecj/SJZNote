>1. 每一个对象都有一个关联的整数，称为引用计数
>2. 当对象被创建时，其引用计数为1，当不使用对象的时候，需要调用release或者autorelease释放对象
>3. 给对象发送retain消息时，其引用计数加1
>4. 给对象发送release消息时，其引用计数减1
>5. 当对象引用计数归0时，ObjC给对象发送dealloc消息销毁对象
>6. 自动释放池，可以延迟对象的释放

自动释放池，系统有一个现成的自动内存管理池，他会随着每一个mainRunloop的结束而释放其中的对像；自动释放池也可以手动创建，他可以让pool中的对象在执行完代码后马上被释放，可以起到优化内存，防止内存溢出的效果（如视频针图片的切换时、创建大量临时对象时等）。

autorelease：自动释放，使对象在超出指定的生存范围时能够自动并正确地释放 （release 即是立即释放）。

### 自动引用计数（ARC）

当我们编译源码时，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数代码。ARC的工作是在编译器的

#### ARC需要遵守的原则

- 不能使用retain、release、retainCount、autorelease
- 不可以使用NSAllocateObject、NSDeallocateObject
- 必须遵守内存管理的命名规则
- 不需要显示的调用dealloc
- 使用@autoreleasePool代替NSAutoreleasePool
- 不可以使用NSZone

#### ARC在编译时做了那些工作

- 自动调用retain与release的方法
- ARC不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。ARC能互相抵消retain、release、autorelease，如果发现在同一个对象上执行了多次保留与释放操作，那么ARC有时可以成对的移除这两个操作

#### ARC在运行时做了哪些工作

- weak关键字，在应用计数为0时，自动设置成nil
- 为了保证向后兼容，ARC在运行时检测到类函数中的autorelease后紧跟其后retain，此时不会直接调用对象的autorelease方法，而是改为调用objc_autoreleaseReturnValue。objc_autoreleaseReturnValue会检查当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行retain操作，则设置全局数据结构中的一个标志位，而不执行autorelease操作。与之相似，如果方法返回一个自动释放池对象，而调用方法的代码要保留此对象，那么此时不直接执行retain，而是改为执行 `objc_retainAoutoreleasedReturnValue`函数。此函数要检测刚才提到的标志位，若已经置位，则不执行retain，设置并检查标志位，要比调用autorelease和retain更快

#### 函数返回一个对象时，会对对象autorelease么？autorelease是什么时候释放的

- 会对对象进行autorelease，因为需要在稍后释放对象，从而给调用者足够长的时间，使其可以在需要时先保留返回值。此方法可以保证对象在跨越方法调用边界时一定存活
- 自己的自动释放池，或者当前线程事件循环结束时

#### 说一下什么是悬垂指针，什么是野指针

- 悬垂指针：指针指向的内存已经释放了，但是指针还存在
- 没有进行初始化的指针

#### 能不能用assign修饰NSObject类型

- 也可以，但是可能出现问题
- 使用assign修饰NSObject类型，赋值之后会被立即释放，对应的属性也就变成了野指针。

#### 内存中的5大区是什么

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值，其操作方式类似于数据结构中的栈
- 堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
- 全局区（静态区）：全局变量和静态变量存储在这一块区域，程序结束后由系统释放
- 文字常量区：常量字符就是放在这里的，程序结束后由系统释放
- 程序代码区：存放函数的二进制代码



